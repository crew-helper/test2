package e2e

import (
	"fmt"
	"os"
	"strings"
	"testing"
	"context"

	// "github.com/kubernetes-sigs/service-catalog/pkg/apis/servicecatalog/v1beta1"
	// servicecatalog "github.com/kubernetes-sigs/service-catalog/pkg/client/clientset_generated/clientset"
	testutil "github.com/mongodb/atlas-osb/test/util"
	// appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/apimachinery/pkg/api/errors"
)

const (
	name = "atlas-operator"
)

var (
	kubeClient  *kubernetes.Clientset
	// svcatClient *servicecatalog.Clientset

	// baseURL hardcoded
	atlasGroupID    = "5ffdac0657666b4b84836fd4"
	atlasPublicKey  = "DJPQJCNN"
	atlasPrivateKey = "864c88bc-531a-46af-bebd-f3d6637bab37"
)

func TestMain(m *testing.M) {
	// Load Kubernetes client config.
	kubeConfigPath := testutil.GetEnvOrPanic("KUBECONFIG")
	config, err := clientcmd.BuildConfigFromFlags("", kubeConfigPath)
	if err != nil {
		panic(err)
	}

	kubeClient, err = kubernetes.NewForConfig(config)
	if err != nil {
		panic(err)
	}

	// svcatClient, err = servicecatalog.NewForConfig(config)
	// if err != nil {
	// 	panic(err)
	// }

	result := m.Run()
	os.Exit(result)
}

func TestCatalog(t *testing.T) {
	t.Parallel()
	kubeConfigPath := testutil.GetEnvOrPanic("KUBECONFIG")
	config, _ := clientcmd.BuildConfigFromFlags("", kubeConfigPath)
	clientset, _ := kubernetes.NewForConfig(config)

	configMapData := make(map[string]string, 0)
uiProperties := `
color.good=purple
color.bad=yellow
allow.textmode=true
`

	configMapData["ui.properties"] = uiProperties
	configMap := corev1.ConfigMap{
	  TypeMeta: metav1.TypeMeta{
		Kind:       "ConfigMap",
		APIVersion: "v1",
	  },
	  ObjectMeta: metav1.ObjectMeta{
		Name:      "game-data",
		Namespace: "game",
	  },
	  Data: configMapData,
	}

	// cm *corev1.ConfigMap =
	// ns_out, err := clientset.CoreV1().Namespaces().Create(context.Background(), "test", metav1.CreateOptions{})
	if _, err := clientset.CoreV1().ConfigMaps("game").Get(context.TODO(), "game-data", metav1.GetOptions{}); errors.IsNotFound(err) {
	  _, _ = clientset.CoreV1().ConfigMaps("game").Create(context.TODO(), &configMap, metav1.CreateOptions{})
	} else {
	  _, _ = clientset.CoreV1().ConfigMaps("game").Update(context.TODO(), &configMap, metav1.UpdateOptions{})

	}

	// namespace := setupTest(t)
	// fmt.Println(namespace)
	// defer cleanupTest(t)

	// // Ensure service plans were generated as well. Both classes and plans
	// // should have been generated by the broker.
	// plans, _ := svcatClient.ServicecatalogV1beta1().ServicePlans(namespace).List(metav1.ListOptions{})
	// assert.NotEmpty(t, plans.Items, "Expected service plans to exist")
}

// // setupTest will create a new namespace for a single test and deploy the
// // broker inside.
// func setupTest(t *testing.T) string {
// 	namespace := namespaceForTest(t)

// 	_, err := kubeClient.CoreV1().Namespaces().Create(
// 		context.TODO(),
// 		&v1.Namespace{
// 			ObjectMeta: metav1.ObjectMeta{Name: namespace},
// 		},
// 		&metav1.CreateOptions{
// 			TypeMeta:     metav1.TypeMeta{},
// 			DryRun:       []string{},
// 			FieldManager: "",
// 		})

// 	// Create(ctx context.Context, namespace *v1.Namespace, opts metav1.CreateOptions) (*v1.Namespace, error)
// 	if err != nil {
// 		t.Fatal(err)
// 	}

// 	// err = deployBroker(namespace)
// 	// if err != nil {
// 	// 	t.Fatal(err)
// 	// }

// 	// err = registerBroker(namespace)
// 	// if err != nil {
// 	// 	t.Fatal(err)
// 	// }

// 	return namespace
// }

// cleanupTest will destroy a test namespace and all its resources.
func cleanupTest(t *testing.T) {
	namespace := namespaceForTest(t)

	err := kubeClient.CoreV1().Namespaces().Delete(context.TODO(), namespace, metav1.DeleteOptions{})
	if err != nil {
		panic(err)
	}
}

// namespaceForTest will return a namespace name based on the current test.
func namespaceForTest(t *testing.T) string {
	return fmt.Sprintf("aosb-e2e-%s", strings.ToLower(t.Name()))
}

// // deployBroker will deploy the broker inside the specified namespace.
// func deployBroker(namespace string) error {
// 	deploy := &appsv1.Deployment{}
// 	testutil.ReadInYAMLFileAndConvert("../../samples/kubernetes/used_for_e2e_tests/deploy.yaml", &deploy)

// 	// Environment Variable
// 	deploy.Spec.Template.Spec.Containers[0].Env = append(deploy.Spec.Template.Spec.Containers[0].Env, v1.EnvVar{
// 		Name:  "ATLAS_BASE_URL",
// 		Value: atlasBaseURL,
// 	})

// 	_, err := kubeClient.AppsV1().Deployments(namespace).Create(deploy)

// 	if err != nil {
// 		return err
// 	}

// 	// Create service to expose the broker deployment internally.
// 	service := &v1.Service{}
// 	testutil.ReadInYAMLFileAndConvert("../../samples/kubernetes/used_for_e2e_tests/service.yaml", &service)
// 	_, err = kubeClient.CoreV1().Services(namespace).Create(service)

// 	return err
// }

// // Create secret and registerBroker will register the broker deployed in deployBroker with the
// // service catalog.
// func registerBroker(namespace string) error {
// 	authSecretName := name + "-auth"

// 	username := atlasPublicKey + "@" + atlasGroupID
// 	password := atlasPrivateKey

// 	// Create secret to hold the basic auth credentials for the broker.
// 	// The broker expects Atlas API credentials as part of the basic auth.
// 	_, err := kubeClient.CoreV1().Secrets(namespace).Create(&v1.Secret{
// 		ObjectMeta: metav1.ObjectMeta{
// 			Name: authSecretName,
// 		},
// 		Data: map[string][]byte{
// 			"username": []byte(username),
// 			"password": []byte(password),
// 		},
// 	})
// 	if err != nil {
// 		panic(err)
// 	}

// 	servicebroker := v1beta1.ServiceBroker{}
// 	testutil.ReadInYAMLFileAndConvert("../../samples/kubernetes/service-broker.yaml", &servicebroker)
// 	servicebroker.Spec.URL = fmt.Sprintf("http://%s.%s", "atlas-service-broker", namespace)

// 	_, err = svcatClient.ServicecatalogV1beta1().ServiceBrokers(namespace).Create(&servicebroker)

// 	return err
// }
